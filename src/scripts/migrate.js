const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { Pool } = require('pg');
const { setupDatabase } = require('./setupDatabase');
const { databases, parseDatabaseConfig } = require('../config/databases');
const { requiredDbVersion, appVersion, isCompatibleVersion } = require('../config/version');
const { createDatabaseBackup } = require('./backup');

async function runMigrations(databaseKey = 'system') {
  console.log('üöÄ Iniciando processo de migra√ß√£o');
  const databaseConfig = databases[databaseKey];
  if (!databaseConfig) {
    throw new Error(`Configura√ß√£o de banco de dados n√£o encontrada para: ${databaseKey}`);
  }

  const parsedConfig = parseDatabaseConfig(databaseConfig);
  const { url, migrationsPath } = databaseConfig;

  console.log('üì¶ Configura√ß√µes de banco de dados:', {
    database: parsedConfig.database,
    host: parsedConfig.host,
    user: parsedConfig.user,
    migrationsPath: migrationsPath
  });

  // Caminho para armazenar backups
  const backupPath = '/var/backups/finance-api-new';

  // Garantir que o diret√≥rio de backup exista
  if (!fs.existsSync(backupPath)) {
    fs.mkdirSync(backupPath, { recursive: true });
  }

  const pool = new Pool({ 
    connectionString: url,
    ssl: false
  });

  let client;
  try {
    console.log('üîß Configurando banco de dados');
    await setupDatabase(databaseKey);

    const fullMigrationsPath = path.join(__dirname, '../migrations/system');
    console.log('üìÇ Caminho completo das migra√ß√µes:', fullMigrationsPath);

    // Log detalhado de migra√ß√µes
    console.log('üîç Detalhes de migra√ß√£o:', {
      migrationsPath,
      fullMigrationsPath,
      exists: fs.existsSync(fullMigrationsPath),
      contents: fs.existsSync(fullMigrationsPath) ? fs.readdirSync(fullMigrationsPath) : 'N√£o existe'
    });

    const files = fs.existsSync(fullMigrationsPath) 
      ? fs.readdirSync(fullMigrationsPath)
        .filter(file => file.endsWith('.sql'))
        .sort()
      : [];
    
    console.log('üìã Arquivos de migra√ß√£o encontrados:', files);

    // Conectar ao banco de dados
    client = await pool.connect();

    // Verificar se as migra√ß√µes j√° foram aplicadas
    let hasPreviousMigrations = false;
    try {
      const migrationCheck = await client.query(`
        SELECT COUNT(*) as migration_count 
        FROM migrations 
        WHERE database_name = $1
      `, [parsedConfig.database]);
      
      hasPreviousMigrations = parseInt(migrationCheck.rows[0].migration_count) > 0;
    } catch (tableNotExistsError) {
      // Se a tabela n√£o existe, consideramos que n√£o h√° migra√ß√µes pr√©vias
      console.log('üìù Tabela de migra√ß√µes n√£o existe. Iniciando primeira migra√ß√£o.');
      hasPreviousMigrations = false;
    }

    // Verificar se h√° migra√ß√µes pendentes
    async function getPendingMigrations(client, files, databaseName) {
      const pendingMigrations = [];

      for (const migrationFile of files) {
        const migrationCheck = await client.query(
          `SELECT * FROM migrations 
           WHERE migration_name = $1 AND database_name = $2`,
          [migrationFile, databaseName]
        );

        if (migrationCheck.rows.length === 0) {
          pendingMigrations.push(migrationFile);
        }
      }

      return pendingMigrations;
    }

    const pendingMigrations = await getPendingMigrations(client, files, parsedConfig.database);

    // S√≥ criar backup se houver migra√ß√µes para aplicar
    let backupFile = null;
    if (pendingMigrations.length > 0 && !hasPreviousMigrations) {
      backupFile = createDatabaseBackup(parsedConfig.database, backupPath, parsedConfig);
      
      if (!backupFile || !fs.existsSync(backupFile)) {
        throw new Error('Falha na cria√ß√£o do backup do banco de dados');
      }
      
      console.log(`üíæ Backup criado: ${backupFile}`);
    } else {
      console.log('üìù Nenhuma migra√ß√£o pendente ou j√° migrado. Backup n√£o necess√°rio.');
    }

    // Se n√£o h√° migra√ß√µes pendentes, retornar
    if (pendingMigrations.length === 0) {
      console.log('üéâ Nenhuma migra√ß√£o pendente. Processo conclu√≠do.');
      return;
    }

    // Dropando e recriando tabelas de migra√ß√£o e configura√ß√£o
    await client.query(`
      DROP TABLE IF EXISTS migrations, system_config CASCADE;
    `);

    // Recriando tabelas
    await client.query(`
      CREATE TABLE migrations (
        id SERIAL PRIMARY KEY,
        migration_name VARCHAR(255) NOT NULL,
        applied_at TIMESTAMPTZ DEFAULT NOW(),
        db_version VARCHAR(50) NOT NULL,
        database_name VARCHAR(100) NOT NULL,
        description TEXT DEFAULT ''
      );

      CREATE TABLE system_config (
        id SERIAL PRIMARY KEY,
        config_key VARCHAR(255) NOT NULL UNIQUE,
        config_value TEXT,
        description TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );
    `);

    // Verificar estrutura da tabela
    async function checkTableStructure(client, tableName, expectedColumns) {
      try {
        const structureQuery = `
          SELECT column_name, data_type 
          FROM information_schema.columns 
          WHERE table_name = $1
        `;
        const result = await client.query(structureQuery, [tableName]);
        
        const currentColumns = result.rows.map(row => ({
          name: row.column_name,
          type: row.data_type
        }));

        // Comparar estruturas
        const missingColumns = expectedColumns.filter(
          expected => !currentColumns.some(
            current => current.name === expected.name && 
                       current.type.toLowerCase() === expected.type.toLowerCase()
          )
        );

        return missingColumns.length === 0;
      } catch (error) {
        // Tabela n√£o existe
        return false;
      }
    }

    // Execu√ß√£o das migra√ß√µes com mais verifica√ß√µes
    console.log(`üîç Migra√ß√µes pendentes: ${pendingMigrations.length}`);

    // Executar apenas migra√ß√µes pendentes
    for (const migrationFile of pendingMigrations) {
      try {
        const migrationSql = fs.readFileSync(path.join(fullMigrationsPath, migrationFile), 'utf8');
        await client.query(migrationSql);
        
        // Registrar migra√ß√£o
        await client.query(
          `INSERT INTO migrations (migration_name, db_version, database_name, description) 
           VALUES ($1, $2, $3, $4)`,
          [migrationFile, requiredDbVersion, parsedConfig.database, `Migra√ß√£o: ${migrationFile}`]
        );
        
        console.log(`‚úÖ Migra√ß√£o aplicada: ${migrationFile}`);
      } catch (migrationError) {
        console.error(`‚ùå Erro na migra√ß√£o ${migrationFile}:`, migrationError);
        throw migrationError;
      }
    }

    // Atualizar vers√£o do banco de dados
    await client.query(`
      INSERT INTO system_config (config_key, config_value, description)
      VALUES ('db_version', $1, 'Vers√£o atual do banco de dados')
      ON CONFLICT (config_key) DO UPDATE 
      SET config_value = $1, updated_at = NOW()
    `, [requiredDbVersion]);

    console.log(`üéâ Migra√ß√£o conclu√≠da com sucesso para vers√£o ${requiredDbVersion}`);

  } catch (error) {
    console.error('‚ùå Processo de migra√ß√£o falhou:', error);
    throw error;
  } finally {
    if (client) {
      client.release();
    }
    await pool.end();
  }
}

module.exports = { runMigrations };
